import os
import re
import sys
from textwrap import TextWrapper

import click
from fontTools.misc.textTools import binary2num
from fontTools.ttLib import TTFont

# Fork of fontTools.misc.cliTools.makeOutputFileName.
# Output dir will be automatically created if it doesn't exist.
numberAddedRE = re.compile(r"#\d+$")


def makeOutputFileName(inputFile, outputDir=None, extension=None, overWrite=False):
    """Generates a suitable file name for writing output.

    Often tools will want to take a file, do some kind of transformation to it,
    and write it out again. This function determines an appropriate name for the
    output file, through one or more of the following steps:

    - changing the output directory
    - replacing the file extension
    - suffixing the filename with a number (``#1``, ``#2``, etc.) to avoid
      overwriting an existing file.

    Args:
        inputFile: Name of input file.
        outputDir: Optionally, a new directory to write the file into.
        extension: Optionally, a replacement for the current file extension.
        overWrite: Overwriting an existing file is permitted if true; if false
            and the proposed filename exists, a new name will be generated by
            adding an appropriate number suffix.

    Returns:
        str: Suitable output filename
    """
    dirName, fileName = os.path.split(inputFile)
    fileName, ext = os.path.splitext(fileName)
    if outputDir:
        # BEGIN EDIT
        if not os.path.exists(outputDir):
            os.mkdir(outputDir)
        # END EDIT
        dirName = outputDir
    fileName = numberAddedRE.split(fileName)[0]
    if extension is None:
        extension = os.path.splitext(inputFile)[1]
    output = os.path.join(dirName, fileName + extension)
    n = 1
    if not overWrite:
        while os.path.exists(output):
            output = os.path.join(
                dirName, fileName + "#" + repr(n) + extension)
            n += 1
    return output


def getFontsList(input_path: str) -> list:
    files = []

    if os.path.isfile(input_path):
        try:
            font = TTFont(input_path)
            files.append(input_path)
        except:
            pass

    if os.path.isdir(input_path):
        for f in os.listdir(input_path):
            try:
                font = TTFont(os.path.join(input_path, f))
                files.append(os.path.join(input_path, f))
            except:
                pass

    if len(files) == 0:
        print('\nNo valid font files found.')

    return files


def getConfigPath(input_path: str) -> str:

    config_file = os.path.join(os.path.dirname(input_path), 'config.json') if os.path.isfile(
        input_path) else os.path.join(input_path, 'config.json')

    return config_file


def getJsonPath(input_path: str) -> str:

    json_file = os.path.join(os.path.dirname(input_path), 'fonts.json') if os.path.isfile(
        input_path) else os.path.join(input_path, 'fonts.json')

    return json_file


def getCsvPath(input_path: str) -> str:
    data_file = os.path.join(os.path.dirname(input_path), 'data.csv') if os.path.isfile(
        input_path) else os.path.join(input_path, 'data.csv')
    return data_file


def wrapString(string: str, initial_indent: int, indent: int, max_lines: int, width: int) -> str:
    wrapped_string = TextWrapper(
        initial_indent=" " * initial_indent,
        subsequent_indent=" " * indent,
        max_lines=max_lines,
        break_on_hyphens=True,
        break_long_words=True,
        width=width
    ).fill(string)
    return wrapped_string


def guessFamilyName(font: TTFont) -> str:
    family_name = None

    try:
        family_name = font['name'].getName(16, 3, 1, 0x409).toUnicode()
    except AttributeError:
        try:
            family_name = font['name'].getName(16, 1, 0, 0x0).toUnicode()
        except AttributeError:
            try:
                family_name = font['name'].getName(1, 3, 1, 0x409).toUnicode()
            except AttributeError:
                try:
                    family_name = font['name'].getName(1, 1, 0, 0x0).toUnicode()
                except AttributeError:
                    pass
    except Exception as e:
        click.secho('ERROR: {}'.format(e))

    return family_name


def getSourceString(font_file : str, string_source: str) -> str:
    font = TTFont(font_file)
    file_name = os.path.basename(font_file)
    name_table = font['name']
    is_cff = 'CFF ' in font

    # Get the source string
    string = None

    if string_source == 'fname':
        string = os.path.splitext(file_name)[0]

    if string_source == '1_1_2':
        str1 = str(name_table.getName(1, 1, 0, 0x0))
        str2 = str(name_table.getName(2, 1, 0, 0x0))
        string = str1 + ' ' + str2

    if string_source == '1_4':
        string = str(name_table.getName(4, 1, 0, 0x0))

    if string_source == '1_6':
        string = str(name_table.getName(6, 1, 0, 0x0))

    if string_source == '1_16_17':
        str1 = str(name_table.getName(16, 1, 0, 0x0))
        str2 = str(name_table.getName(17, 1, 0, 0x0))
        string = str1 + ' ' + str2

    if string_source == '1_18':
        string = str(name_table.getName(18, 1, 0, 0x0))

    if string_source == '3_1_2':
        str1 = str(name_table.getName(1, 3, 1, 0x409))
        str2 = str(name_table.getName(2, 3, 1, 0x409))
        string = str1 + ' ' + str2

    if string_source == '3_4':
        string = str(name_table.getName(4, 3, 1, 0x409))

    if string_source == '3_6':
        string = str(name_table.getName(6, 3, 1, 0x409))

    if string_source == '3_16_17':
        str1 = str(name_table.getName(16, 3, 1, 0x409))
        str2 = str(name_table.getName(17, 3, 1, 0x409))
        string = str1 + ' ' + str2

    if is_cff:
        cff_table = font['CFF '].cff
        if string_source == 'cff_1':
            string = str(cff_table.fontNames[0])

        if string_source == 'cff_2':
            string = str(cff_table.topDictIndex[0].FullName)

    return string


def calcCodePageRanges(unicodes):
    """Given a set of Unicode codepoints (integers), calculate the
    corresponding OS/2 CodePage range bits.
    This is a direct translation of FontForge implementation:
    https://github.com/fontforge/fontforge/blob/7b2c074/fontforge/tottf.c#L3158
    """
    codepageRanges = set()

    chars = [chr(u) for u in unicodes]

    hasAscii = set(range(0x20, 0x7E)).issubset(unicodes)
    hasLineart = "┤" in chars

    for char in chars:
        if char == "Þ" and hasAscii:
            codepageRanges.add(0)  # Latin 1
        elif char == "Ľ" and hasAscii:
            codepageRanges.add(1)  # Latin 2: Eastern Europe
            if hasLineart:
                codepageRanges.add(58)  # Latin 2
        elif char == "Б":
            codepageRanges.add(2)  # Cyrillic
            if "Ѕ" in chars and hasLineart:
                codepageRanges.add(57)  # IBM Cyrillic
            if "╜" in chars and hasLineart:
                codepageRanges.add(49)  # MS-DOS Russian
        elif char == "Ά":
            codepageRanges.add(3)  # Greek
            if hasLineart and "½" in chars:
                codepageRanges.add(48)  # IBM Greek
            if hasLineart and "√" in chars:
                codepageRanges.add(60)  # Greek, former 437 G
        elif char == "İ" and hasAscii:
            codepageRanges.add(4)  # Turkish
            if hasLineart:
                codepageRanges.add(56)  # IBM turkish
        elif char == "א":
            codepageRanges.add(5)  # Hebrew
            if hasLineart and "√" in chars:
                codepageRanges.add(53)  # Hebrew
        elif char == "ر":
            codepageRanges.add(6)  # Arabic
            if "√" in chars:
                codepageRanges.add(51)  # Arabic
            if hasLineart:
                codepageRanges.add(61)  # Arabic; ASMO 708
        elif char == "ŗ" and hasAscii:
            codepageRanges.add(7)  # Windows Baltic
            if hasLineart:
                codepageRanges.add(59)  # MS-DOS Baltic
        elif char == "₫" and hasAscii:
            codepageRanges.add(8)  # Vietnamese
        elif char == "ๅ":
            codepageRanges.add(16)  # Thai
        elif char == "エ":
            codepageRanges.add(17)  # JIS/Japan
        elif char == "ㄅ":
            codepageRanges.add(18)  # Chinese: Simplified chars
        elif char == "ㄱ":
            codepageRanges.add(19)  # Korean wansung
        elif char == "央":
            codepageRanges.add(20)  # Chinese: Traditional chars
        elif char == "곴":
            codepageRanges.add(21)  # Korean Johab
        elif char == "♥" and hasAscii:
            codepageRanges.add(30)  # OEM Character Set
        # Symbol bit has a special meaning (check the spec), we need
        # to confirm if this is wanted by default.
        # elif chr(0xF000) <= char <= chr(0xF0FF):
        #    codepageRanges.add(31)          # Symbol Character Set
        elif char == "þ" and hasAscii and hasLineart:
            codepageRanges.add(54)  # MS-DOS Icelandic
        elif char == "╚" and hasAscii:
            codepageRanges.add(62)  # WE/Latin 1
            codepageRanges.add(63)  # US
        elif hasAscii and hasLineart and "√" in chars:
            if char == "Å":
                codepageRanges.add(50)  # MS-DOS Nordic
            elif char == "é":
                codepageRanges.add(52)  # MS-DOS Canadian French
            elif char == "õ":
                codepageRanges.add(55)  # MS-DOS Portuguese

    if hasAscii and "‰" in chars and "∑" in chars:
        codepageRanges.add(29)  # Macintosh Character Set (US Roman)

    # when no codepage ranges can be enabled, fall back to enabling bit 0
    # (Latin 1) so that the font works in MS Word:
    # https://github.com/googlei18n/fontmake/issues/468
    if not codepageRanges:
        codepageRanges.add(0)

    return codepageRanges


def intListToNum(intList, start, length):
    all = []
    bin = ""
    for i in range(start, start + length):
        if i in intList:
            b = "1"
        else:
            b = "0"
        bin = b + bin
        if not (i + 1) % 8:
            all.append(bin)
            bin = ""
    if bin:
        all.append(bin)
    all.reverse()
    all = " ".join(all)
    return binary2num(all)


def is_nth_bit_set(x: int, n: int) -> bool:
    if x & (1 << n):
        return True
    return False


def set_nth_bit(x: int, n: int) -> int:
    return x | 1 << n


def unset_nth_bit(x: int, n: int) -> int:
    return x & ~(1 << n)


class RequiredIf(click.Option):
    def __init__(self, *args, **kwargs):
        self.required_if: list = kwargs.pop("required_if")

        assert self.required_if, "'required_if' parameter required"
        kwargs["help"] = (kwargs.get("help", "") + "Option is mutually inclusive with " + ", ".join(
            self.required_if) + ".").strip()
        super(RequiredIf, self).__init__(*args, **kwargs)

    def handle_parse_result(self, ctx, opts, args):
        current_opt: bool = self.name in opts
        for mutinc_opt in self.required_if:
            if mutinc_opt not in opts:
                if current_opt:
                    raise click.UsageError(
                        "Illegal usage: '" + str(self.name) + "' is mutually inclusive with " + str(mutinc_opt) + ".")
                else:
                    self.prompt = None
        return super(RequiredIf, self).handle_parse_result(ctx, opts, args)
